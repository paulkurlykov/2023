////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// ДОСТУПЫ К ЭЛЕМЕНТАМ ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const elemByID = document.getElementById('box1'); // доступ по ID. Возвращает: <div class="like" id="box1"></div>
const elemByClassName = document.getElementsByClassName('like'); // Возвращает массив с элементами этого класса - HTMLCollection.
const classFilter = document.querySelectorAll('.like:not(.subscribe)'); // Тоже самое, но можно отфильтровать слово в классе. Возвращает коллекцию Nodelist c подходящими узлами. 
const elementByTagName = document.getElementsByTagName('div'); // Возвращает массив HTMLCollection.
const specificElementByTagName = document.getElementsByTagName('div')[2]; // возвращает - <div class="subscribe"></div>

const queryElem = document.querySelector('ul'); // Возвращает первый элемент с указаным селектором
const queryAllElem = document.querySelectorAll('.like'); // возвращает коллекцию NodeList с элементами селектора
const specQueryAllElem = document.querySelectorAll('.like')[1]; // возвращает указанный под индексом элемент - <div class="like subscribe"></div>

const nextNode = document.querySelector('.like').nextSibling; // возвращает следующий Node - #text
const previousNode = document.querySelector('.like').previousSibling; // возвращает предыдущий Node - #text
const parentNode = document.querySelector('li').parentNode; // возвращает родительский Node - <ul><li>Корчи</li><li>Йончи</li></ul>
const childNode = document.querySelector('body').childNode; // возвращает дочерний Node - undefined

const nextElem = document.querySelector('.like').nextElementSibling; // возвращает следующий элемент - <div class="subscribe"></div>
const previousElem = document.querySelector('.like').previousElementSibling; // возвращает предыдущий элемент - <ul><li>Корчи</li><li>Йончи</li></ul>
const parentElem = document.querySelector('li').parentElement; // возвращает весь родительский элемент - <ul><li>Корчи</li><li>Йончи</li></ul>
const firstChild = document.querySelector('ul').firstElementChild; // возвращает первый дочерний элемент - <li>Корчи</li>
const lastChild = document.querySelector('ul').lastElementChild; // возвращает первый дочерний элемент - <li>Йончи</li>
const children = document.querySelector('ul').children; // показывает массив HTML Collection с дочерними элементами
const specChild = document.querySelector('ul').children[1]; // показывает дочерний элемент под указанным индексом - <li>Йончи</li>

for(let node of document.body.childNodes) { //перебор элементов выбранного элемента. Возвращает чисто код - все элементы со вложенностями
    if(node.nodeName == '#text') {
        continue;
    }
    console.log(node);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// РАЗМЕЩЕНИЕ СОЗДАНИЕ УДАЛЕНИЕ ЭЛЕМЕНТОВ ////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Создаем DIV
const div = document.createElement('div'); // в скобках метода указываем название тега. Не переменная, а в скобках. мы создали простой блок DIV. Но он еще не добавлен на страницу

// Присваиваем DIV'у класс
div.classList.add('black'); // в скобках прописывается имя класса, как строка. 

// Размещаем DIV в КОНЕЦ выбранного блока в html - APPEND
document.body.append(div); // слева-направо - мы обращаемся к общей странице[document], затем к [body], и кладем (append) блок [div] в КОНЕЦ блока body

// Размещаем DIV в НАЧАЛО выбранного блока в html - PREPEND
const newHeart = document.createElement('div'); // создали блок
newHeart.classList.add('heart'); // присвоили ему класс
document.querySelector('.wrapper').prepend(newHeart); // добавляем его в блок с классом wrapper (где наши сердца). Это отразится в HTML-коде только в браузере! Здесь ничего не появится. 
// document.querySelectorAll('.heart').forEach(item => item.style.cssText = 'background-color: grey'); // обращение к стилю без переменных
const g = document.querySelectorAll('.heart'); 
g.forEach(item => item.style.cssText = 'background-color: grey'); // обращение к стилю с переменными

// Размещаем DIV перед выбранным элементом - BEFORE
const redCircle = document.createElement('div'); // создаем новый блок
redCircle.classList.add('red-circle'); // присваиваем ему класс red-circle
const circle = document.getElementsByClassName('circle'); // создаем переменную, туда кладем массив элементов с классом circle
circle[0].before(redCircle); // указываем, перед каким элементом его разметить
document.getElementsByClassName('red-circle')[0].style.cssText = 'border-radius: 50px; background-color: red; width: 80px; height: 80px; margin-top: 10px'; // стилизуем типа

// Размещаем DIV после выбранного элемента - AFTER
const yellowCircle = document.createElement('div');
yellowCircle.classList.add('yellow-circle');
circle[2].after(yellowCircle);
document.getElementsByClassName('yellow-circle')[0].style.cssText = 'border-radius: 50px; background-color: yellow; width: 80px; height: 80px; margin-top: 10px';

///////////////////// УДАЛЕНИЕ ЭЛЕМЕНТА - REMOVE

yellowCircle.remove(); // указываем переменную, в которую мы помещали созданный блок

///////////////////// ЗАМЕНА ОДНОГО ЭЛЕМЕНТА НА ДРУГОЙ - REPLACE WITH

circle[1].replaceWith(yellowCircle); // сначала указываем элемент, который мы хотим заменить. 
// Затем сам метод, и в скобках метода указываем, на что заменить. У нас это блок в переменной yellowCircle, который мы выше удалили.

///// ЗАМЕНА ЭЛЕМЕНТА ТУПО НА КОД HTML
// Сначала удалили старые элементы, затем скопировали тот код html, который нужно будет вставить с динамическими изменениями
let newLi = document.createElement('li');
newLi.innerHTML = `<li class="promo__interactive-item">${i+1}) ${films}<div class="delete"></div></li>`;
oldLi[i].replaceWith(newLi);




///////////////////// УСТАРЕВШИЕ КОНСТРУКЦИИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// appendchild (вместо APPEND)
// document.body.appendChild(div); // все тоже самое, просто название метода другое

// insertBefore - вместо BEFORE
// document.getElementsByTagName('body')[0].insertBefore(yellowCircle, circle[0]); // сначала указываем блок, в который мы добавим наш блок.
// Затем сам метод, в скобках два аргумента - 1. Наш блок, который вставляем. 2. Блок, перед которым ставим наш блок. 

// removeChild - вместо REMOVE
// document.getElementsByTagName('body')[0].removeChild(circle[0]);

// replaceChild - вместо REPLACE WITH
// document.getElementsByTagName('body')[0].replaceChild(yellowCircle, circle[0]); // в скобках два аргумента. 1. Новый блок 2. Старый блок.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// ОБРАЩЕНИЕ К СТИЛЮ ЭЛЕМЕНТА STYLE ////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

box.style.backgroundColor = 'blue'; // Сначала мы обращаемся к элементу(ам) [box]. Затем через точку указываем style - доступ к подобъекту [style]. И после этого указываем свойство, как в CSS,
// только в camelCase. И затем этому свойства присваиваем значение, как в CSS. Значение СТРОКОЙ - ['blue'], так как мы должны передать буковки. 
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

//Дерево объектов для нашей переменной [box] выглядит так:

// box { // box - это переменная, в которой находится элемент. Он представлен в виде объекта. 
//     свойство1: '', // этот обьект имеет много-много свойств и методов, значения которых по умолчанию ''. 
//     свойство2: '',
//     ...,
//     style: { // среди них есть свойство style, значение которого еще один объект. 
//         textAlign: '', // Внутри объекта style имеются свойства, имена которых совпадают с CSS. Значения по умолчанию также ''.
//         textShadow: '',
//         другие_свойства_CSS: '',
//     }
// }

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

box.style.width = '500px'; // Тоже строкой, потому что есть строчные символы. Мы должны указывать единицы измерений обязательно, иначе нас не поймут. 

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
// Данные свойства становятся как бы инлайн свойствами элемента. Консоль будет видеть эти стили добавленными в качестве аргумента в теге. Таким образом, он имеет приоритет перед CSS
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

btns[1].style.borderRadius = '100%'; // Здесь мы сначала выбрали индексом конкретный элемент из массива. Затем обращаемся к стилю, и задаем радиус. Строкой, потому что указываем строчный символ %

// circles.style.backgroundColor = 'red'; // выдаст ошибку, потому что у нас массив, а мы не указали конкретный индекс, поэтому все обращается к общему массиву, который не имеет таких свойств. 

//////////////////////////////////////////// НЕСКОЛЬКО СТИЛЕЙ В ОДНОЙ ОПЕРАЦИИ

box.style.cssText = 'opacity: 0.5; heigth: 500px; border: 5px double green'; // так записываются несколько свойств для CSS
// при использовании cssText сбрасываются выполненные ранее обращения к стилю этого элемента
let h = 200;
box.style.cssText = `background-color: #08b6fb; height: ${h}px; border-radius: 10px`; // можно подставлять в строку параметры при помощи косых кавычек
// также новое обращение полностью перекрывает старое. Ну как с переменными, мы назначили новое значение, старое полностью недействительно.

//////////////////////////////////////////// МАССОВОЕ ОБРАЩЕНИЕ К МНОГИМ ЭЛЕМЕНТАМ

// цикл for для всех случаев - почти не используется, так как все пользуются querySelectorAll

for(let i=0; i<btns.length; i++) {
    btns[i].style.cssText = 'border-radius: 10px; background-color: saddlebrown; margin: 10px';
}

// цикл forEach для querySelectorAll

hearts.forEach(item => item.style.background = 'green'); // item - элемент в массиве, он будет перебираться. 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////// ВСТАВКА КОНТЕНТА В HTML //////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////// INNERHTML - вставляем структуру HTML в блок

// Вставляем текст
box.innerHTML = 'Извините, а вы рыб продаете?'; // вставка текста в блок, looks like: <div class="box" id="box">Извините, а вы рыб продаете?</div>

// встваляем заголовок H1
box.innerHTML = '<h1>Красивое...</h1>'; // Передаем заголовок h1 в этот блок
// мы не можем передать больше одной структуры в один блок. Если надо больше, то нужно создавать блоки внутри блока. 

// TEXT CONTENT

box.textContent = 'Вы продоёте рыбов?'; // точно также, если до этого мы использовали метод контента с данным элементом ранее, этот метод его заменит.
box.textContent = '<h1>Вы продоёте рыбов?</h1>'; // в отличии от innerHTML, здесь вставленный код html будет просто текстом, а не кодом. 

// 

box.insertAdjacentHTML('beforeend', '<h2>insertadjacent</h2>');  // принимает два аргумента. 1. Ключевое слово в кавычках (означает куда вставлять). 2. Код, который мы вставляем в кавычках. 
// afterbegin - вставляет код в начало выбранного [box] элемента, то есть включает его туда
// beforebegin - вставляем код перед выбранным [box] элементом, не включая его в выбранный элемент. 
// afterend - вставляет код после выбранного [box] элемента, не включая его туда. 
// beforeend - вставляет код в конец выбранного [box] элемента, включая его туда. 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// СОБЫТИЯ /////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\///\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
///////////////// УСТАНОВКА ОБРАБОТЧИКА СОБЫТИЙ
let btn1 = document.querySelector('#btn');

btn1.addEventListener( 'click', function() { // в параметрах метода указываем тип события как строку, вторым аргументом идет функция, 
                                             //в теле которой код, который будет выполнятся при клике на элемент
    alert('click2');
} );
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

// btn1.addEventListener( 'click', () => { // ВТОРОЙ вариант записи метода с краткой записью функции
//     alert('click2');
// } );

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

// onclick = () => { // ТРЕТИЙ вариант записи метода с краткой записью функции, где сама функция записывается отдельно, а аргументом метоа идет название функции
//     alert('Its click again');
// };

// btn1.addEventListener('click', onclick); // здесь пишем название функции без скобок.

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

//////// Установка обработчика с EVENT
btn1.addEventListener( 'click', function(event) { // указываем аргумент - event (название любое)
console.log(event);
} );

//////// Дополнительные действия с полученными данными EVENT
btn1.addEventListener( 'click', function(event) { // указываем аргумент - event (название любое)
    console.log(event.target); // получаем код того элемента, на который кликнули
    event.target.style.background = 'red'; // после клика сделали кнопку красной
    } );

//////// УДАЛЕНИЕ обработчика

// let btn1 = document.querySelector('#btn');

function onclick(event) { // Для удаления обработчика необходимо, чтобы функция была вынесена отдельно (как в третьем варианте), и имела название. 
    alert(event.target); // 
}

btn1.addEventListener('click', onclick); // В таком случае мы назначим обработчик только с помощью названия
btn1.removeEventListener('click', onclick); // И удалим его тоже с помощью названия. Кстати, метод удаления функции можно пихать в тело главной функции, и запускать при условии IF

////////// ОТМЕНА ДЕЙСТВИЙ БРАУЗЕРА ПО УМОЛЧАНИЮ

link.addEventListener('click', function(event) {
    event.preventDefault(); // данный метод в обработчике событий отменяет стандартное действие браузера. В данном случае, перехода по ссылке не случится. 
    console.log(event.target); // А что будет вместо этого? Будет то, что мы укажем ниже
});

//// ПРИМЕНЕНИЕ И УДАЛЕНИЕ ОБРАБОТЧИКА К МНОГИМ ЭЛЕМЕНТАМ - forEach

btns.forEach(buttn => { // применяем foreach к переменной, в которой массив с кнопками. items = buttn. 
buttn.addEventListener('click', onclick);
});

/// УДАЛЕНИЕ ОБРАБОТЧИКА С МНОГИХ ЭЛЕМЕНТОВ
btns.forEach(buttn => { // так
    buttn.removeEventListener('click', onclick);
});

/////// ОГРАНИЧЕНИЕ КОЛ-ВА СРАБАТЫВАНИЙ СОБЫТИЯ - ONCE

btn1.addEventListener('click', onclick, {once: true}); // третьим аргументом в метод регистрации обработчика ставим объект, свойство которого будет [once], значение [true].

/////// ЗАГРУЗКА СКРИПТА ПОСЛЕ ПОЛНОЙ ЗАГРУЗКИ DOM ЭЛЕМЕНТОВ

document.addEventListener('DOMContentLoaded', () => {
    // сюда весь-весь скрипт
});


